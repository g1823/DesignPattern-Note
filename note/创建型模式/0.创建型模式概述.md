## 创建型模式概述

### 🌱 基本介绍：

创建型模式（Creational Pattern）专注于对象的**创建过程**，将对象的**创建与使用分离**。这样做可以达到：

- 解耦构建和使用，提升系统的扩展性和灵活性。
- 统一对象创建方式，避免重复代码。
- 遵循**单一职责原则**和**开闭原则**。

在软件系统中，类的实例化是基础行为，创建型模式将这些对象的创建过程标准化、可复用、可拓展。

------

### 🍎 生活类比说明：

比如我们想吃苹果：

| 获取方式 | 描述                     | 特点                         |
| -------- | ------------------------ | ---------------------------- |
| 自己种树 | 自己栽种苹果树，等待收获 | 效率低，专业性不足，流程复杂 |
| 去超市买 | 超市直接提供成品苹果     | 简洁高效，专业生产，灵活购买 |



🔍 **结论**：第二种方式即“由专门模块创建对象”更合理，对应**创建型模式的核心思想**：**将对象创建过程交给专业模块负责，使用者只需消费，不必了解实现细节。**

------

## 创建型模式对比表

| 模式             | 定义                                                        | 说明/场景                                                    | 优点                             | 难度 | 使用频率 |
| ---------------- | ----------------------------------------------------------- | ------------------------------------------------------------ | -------------------------------- | ---- | -------- |
| **单例模式**     | 保证一个类只有一个实例，并提供一个全局访问点。              | 适用于**全局唯一资源**管理，如配置类、缓存池、线程池、日志对象。 | 节省资源，统一管理，线程安全可控 | ⭐    | ★★★☆☆    |
| **简单工厂模式** | 根据参数返回不同的子类对象。**不属于GoF标准23种设计模式**。 | 适用于**对象创建逻辑简单**、种类不多、变化不频繁的场景。     | 使用简单，集中管理               | ⭐    | ★★★★☆    |
| **工厂方法模式** | 定义一个创建对象的接口，由子类决定要实例化的类。            | 适用于**对象种类多、变化频繁**的系统，需要通过扩展新增对象。 | 符合开闭原则，扩展方便           | ⭐⭐   | ★★★★★    |
| **抽象工厂模式** | 提供创建**一系列相关或依赖对象**的接口，无需指定具体类。    | 适用于产品族（如 GUI 库中的按钮、输入框等）创建，多个对象需**统一变换**的场景。 | 产品族扩展方便，隐藏具体产品细节 | ⭐⭐⭐  | ★★★★★    |
| **原型模式**     | 通过**复制已有对象**创建新对象，避免重新构造。              | 对象构建成本高或包含复杂初始化逻辑时（如深克隆、多线程安全要求）。 | 快速复制，避免重复创建           | ⭐⭐   | ★★★☆☆    |
| **建造者模式**   | 将一个复杂对象的构建与表示分离，同样过程可创建不同表现。    | 适用于构建过程复杂、需要**一步步组装**的对象，如**表单、SQL、文档生成器**等。 | 可控制构建流程，复用构建逻辑     | ⭐⭐⭐  | ★★☆☆☆    |



## 使用建议

- ✅ 如果只允许一个实例 → 用 **单例模式**
- ✅ 若需要根据参数返回对象 → 先考虑 **简单工厂**
- ✅ 若新增类较多且频繁变化 → 用 **工厂方法**
- ✅ 若一组产品要一起变化 → 用 **抽象工厂**
- ✅ 若希望复制已有对象 → 用 **原型模式**
- ✅ 若对象构建过程复杂分步骤 → 用 **建造者模式**