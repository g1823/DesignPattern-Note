# 结构型模式（Structural Patterns）

## 一、定义与核心思想
结构型模式关注如何**组合类与对象**以形成更大的结构。  
它主要解决的是：在不修改原有代码的情况下，**通过对象之间的连接、包装、代理或抽象**，实现更灵活、更低耦合的系统设计。

> 🌱 核心目标：  
> - 提升系统的复用性与扩展性  
> - 解耦抽象与实现  
> - 动态增强对象功能  
> - 简化复杂系统调用  
> - 减少内存和资源占用  

---

## 二、模式分类概览

| 模式名称   | 主要目的           | 关键思想                                 | 典型应用                     |
| ---------- | ------------------ | ---------------------------------------- | ---------------------------- |
| 适配器模式 | 接口转换           | 将一个类的接口转换为客户期望的另一个接口 | 系统接口兼容、旧系统改造     |
| 桥接模式   | 抽象与实现分离     | 通过组合代替继承，使两个维度独立变化     | 图形形状与颜色、数据库与驱动 |
| 组合模式   | 部分-整体统一      | 将对象组合成树形结构以表示层级关系       | 文件系统、组织架构树         |
| 装饰器模式 | 动态增强对象功能   | 通过包装对象添加新行为，不改变其结构     | Java I/O流、AOP拦截器        |
| 外观模式   | 统一接口、简化使用 | 为复杂子系统提供一个统一入口             | 启动流程、模块集成           |
| 享元模式   | 对象共享、节省内存 | 共享相同的内部状态、外部参数化           | 棋盘、文字渲染、大量重复对象 |
| 代理模式   | 控制访问、功能增强 | 使用代理对象代替真实对象进行访问         | 缓存、远程调用、权限验证     |

| 模式           | 定义                                                         | 说明 / 场景                                                  | 难度 | 使用频率 |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---- | -------- |
| **适配器模式** | 将一个类的接口转换为客户端所期望的另一种接口，使得原本由于接口不兼容而不能一起工作的类可以一起工作 | 系统接口不兼容时，通过中间层适配。                           | ⭐⭐   | ★★★★☆    |
| **桥接模式**   | 将抽象与实现分离，使它们可以独立变化。                       | 当事物存在两个独立变化的维度时，将两个变化因素抽取出来形成高层次的关联关系，使原本复杂的类继承结构变得相对简单，极大减少系统中类的个数。即抽象与实现都有可能扩展时，如“形状-颜色”双维度变化。 | ⭐⭐⭐  | ★★★☆☆    |
| **组合模式**   | 将对象组合成树形结构以表示“部分一整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。 | 通过面向对象技术来实现对系统中存在的容器对象和叶子对象进行统一操作，且客户端无须知道操作对象是容器还是其成员，例如文件系统、组织结构等层级关系。 | ⭐⭐⭐  | ★★★★☆    |
| **装饰器模式** | 动态地给对象添加额外职责，而不改变其结构。                   | 不使用继承而通过关联关系来调用现有类中的方法，达到复用的目的，并使得对象的行为可以灵活。变化动态扩展功能，如流式操作、过滤链。 | ⭐⭐⭐  | ★★★☆☆    |
| **外观模式**   | 为子系统提供一个统一入口，简化复杂接口。                     | 封装多个模块调用，如系统启动、整合API。                      | ⭐⭐   | ★★★★★    |
| **享元模式**   | 共享对象以支持大量细粒度对象的复用。                         | 通过共享技术实现对象的重用，大幅度节约系统的内存，该模式关心系统的性能与资源利用情况。例如：重复对象多，占用内存大，如字符、棋子等。 | ⭐⭐⭐⭐ | ★☆☆☆☆    |
| **代理模式**   | 通过代理对象控制对目标对象的访问。                           | 权限控制、懒加载、远程访问等。                               | ⭐⭐⭐  | ★★★★★    |

## 三、结构型模式核心原则

1. **多用组合，少用继承**  
   → 桥接、装饰器、组合模式都依赖对象组合实现灵活扩展。  
2. **面向接口编程**  
   → 适配器、代理、外观都以接口为契约进行适配与封装。  
3. **解耦模块间依赖**  
   → 外观模式、桥接模式减少了模块直接依赖关系。  
4. **动态扩展与复用**  
   → 装饰器与享元模式都提高了对象的运行时灵活性与内存效率。

---

## 四、结构型模式应用场景对比

| 模式   | 动机           | 是否改变接口 | 是否增强功能 | 典型特征   |
| ------ | -------------- | ------------ | ------------ | ---------- |
| 适配器 | 兼容不同接口   | ✅ 改变       | ❌ 不增强     | 接口转换器 |
| 桥接   | 解耦抽象与实现 | ✅ 分离       | ❌ 不增强     | 多维扩展   |
| 组合   | 统一部分与整体 | ❌ 不变       | ❌ 不增强     | 树形结构   |
| 装饰器 | 动态功能扩展   | ❌ 不变       | ✅ 增强       | 层层包装   |
| 外观   | 简化调用       | ✅ 提供新接口 | ❌ 不增强     | 门面统一   |
| 享元   | 减少资源占用   | ❌ 不变       | ❌ 不增强     | 对象池     |
| 代理   | 控制访问       | ❌ 不变       | ✅ 可增强     | 代替访问   |

